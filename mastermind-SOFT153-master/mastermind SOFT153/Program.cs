using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace mastermind_SOFT153
{
    /// <summary>
    /// Used to store and manage the queue used for storing the history 
    /// </summary>
    class queue
    {
        public int front = -1;      // oldest entry removed here
        public int back = -1;       // youngest entry added here
                                    // negative values indicate empty queue
        public string[] data = new string[100]; 
    }

    /// <summary>
    /// The main program - plays a mastermind game against a random code
    /// </summary>
    class Program
    {
        /// <summary>
        /// A game of mastermind where the player faces a computer generated code
        /// </summary>
        static void Main(string[] args)
        {
            string nInput, mInput;          // These are the actual text inputs    
            int n, m;                       // n is the length and m is the range

            string restartChoice;           // A letter that represents whether or not the player wishes to restart

            do
            {
                Console.Clear();

                Console.WriteLine("\nSoft 153 Mastermind");
                Console.WriteLine("==================================================================");

                Console.Write("\nPlease enter how long you would like the code to be: ");
                nInput = Console.ReadLine();        // Retrieve the desired length of code

                while (!Int32.TryParse(nInput, out n))      // Error checking on the code length
                {
                    Console.WriteLine("Not a valid number, try again.");

                    nInput = Console.ReadLine();
                }

                Console.Write("How many values would like available (standard is 6): ");
                mInput = Console.ReadLine();        // retrieve the desired range of options

                while (!Int32.TryParse(mInput, out m))      // Error checking on the range of values
                {
                    Console.WriteLine("Not a valid number, try again.");

                    mInput = Console.ReadLine();
                }

                MainGameLoop(n, m);     // Enter main loop after asking user for variables

                Console.Write("Would you like to play again? (y/n)  ");
                restartChoice = Console.ReadLine();
            }
            while (restartChoice == "y");

        }

        /// <summary>
        /// Generate the code and compare user guesses to it until they win - then ask for restart
        /// </summary>
        /// <param name="n"> length of code </param>
        /// <param name="m"> range of values available </param>
        static void MainGameLoop(int n, int m)
        {
            bool isCorrect = false;     // Whether or not the users guess was correct
            int[] hiddenCode = new int[n];      // The code generated by the computer which the player is trying to match
            int[] guessedCode = new int[n];     // The code being proposed by the player
            int[] hiddenCodeUnchanged = new int[n];     // The original hidden code - this allows for the restting of the code after it has been checked through
            bool debug = true;      // Whether or not debug mode is active (shows code that is being aimed for)

            queue history = new queue();        // The guess history queue

            GenerateSecretCode(n, m, ref hiddenCode);       // Create a code to try and guess

            for (int i = 0; i < n; i++)     // Replicate hidden code for later restoration
            {
                hiddenCodeUnchanged[i] = hiddenCode[i];
            }

            if (debug)       // Print out the secret code
            {
                Console.Write("\n### DEBUG ### ");
                for (int i = 0; i < n; i++)
                {
                    Console.Write(hiddenCode[i]);
                }
                Console.Write("\n\n");
            }

            while (!isCorrect)       // While the player has not yet guessed correctly
            {
                PlayerTurn(n, m, ref guessedCode, debug, ref history);      // Get a guess from the player
                EvaluatePlayerTurn(guessedCode, hiddenCode, n, ref isCorrect, history);      // Evaluate the result

                for (int i = 0; i < n; i++)     // Restore hidden code
                {
                    hiddenCode[i] = hiddenCodeUnchanged[i];
                }
            }
        }

        /// <summary>
        /// Creates a secret code of desired length and range
        /// </summary>
        /// <param name="length"> n </param>
        /// <param name="range"> m </param>
        /// <param name="hiddenCode"> The code to be created, this is a ref so it will affect the variable in the original method </param>
        static void GenerateSecretCode(int length, int range, ref int[] hiddenCode)
        {
            Random r = new Random();

            for (int i = 0; i < length; i++)
            {
                hiddenCode[i] = r.Next(1, range + 1);
            }
        }

        /// <summary>
        /// Takes a guess from the player
        /// </summary>
        /// <param name="length"> length of code </param>
        /// <param name="range"> max possible value </param>
        /// <param name="emptyPlayerCode"> reference to the previously created player code </param>
        static void PlayerTurn(int length, int range, ref int[] emptyPlayerCode, bool debug, ref queue history)
        {
            string tempInput;       // Holds the value entered by the player before it is saved into the array
            int tempNum;

            string stringForHistory = "";

            if(!IsEmpty(history))       // Prints previous guesses
            {
                Console.WriteLine("\nThese are your previous guesses: ");
                PrintQueue(history);
            }
            
            Console.ForegroundColor = ConsoleColor.Green;
            Console.Write("Time to make your guess...\n\n");
            Console.ResetColor();

            for (int i = 0; i < length; i++)        // Retrieves each number of the guess individually
            {
                Console.WriteLine("Please enter a value between 1 and {0}: ", range);
                tempInput = Console.ReadLine();

                while (!Int32.TryParse(tempInput, out tempNum))
                {
                    Console.WriteLine("Not a valid number, try again.");

                    tempInput = Console.ReadLine();    
                }

                stringForHistory += tempInput;

                emptyPlayerCode[i] = tempNum;
            }

            Add(history, stringForHistory);
        }

        /// <summary>
        /// Looks at the players guess and determines how many black pegs and how many white pegs should be given
        /// </summary>
        /// <param name="guessedCode"> The code provided by the player </param>
        /// <param name="hiddenCode"> The code that the player is trying to guess </param>
        /// <param name="n"> The length of the code </param>
        /// <param name="isCorrect"> Whether or not the current guess is correct </param>
        static void EvaluatePlayerTurn(int[] guessedCode, int[] hiddenCode, int n, ref bool isCorrect, queue history)
        {
            int b = 0;      // Initialise number of each colour peg
            int w = 0;

            Console.Write("\n");

            for (int i = 0; i < n; i++) // find all black pegs first
            {
                if (guessedCode[i] == hiddenCode[i])        // If the numbers match, a black peg is awarded
                {
                    b++;
                    hiddenCode[i] = 0;     // To prevent the digit being counted again, it is set to 0
                    guessedCode[i] = 0;
                    Console.Write("| Black Peg | ");
                }
            }

            for (int i = 0; i < n; i++) // find all white pegs second
            {
                for (int j = 0; j < n; j++)     // Loop through again, this checks to see if the guessed digit is present but in a different location
                {
                    if (guessedCode[i] == hiddenCode[j] && guessedCode[i] != 0)     // Can break out of the loop if necessary
                    {
                        hiddenCode[j] = 0;
                        guessedCode[i] = 0;
                        w++;
                        Console.Write("| White Peg | ");
                    }
                }
            }

            Console.Write("\n");

            if (b == n)     // If the number of black pegs equals the length of the code, the player has won
            {
                isCorrect = true;
                Console.WriteLine("\nCongratulations! This is all your guesses\n");
                PrintQueue(history);

                history = new queue();
            }

        }

        #region Queue Functions

        /// <summary>
        /// Add an element to the queue
        /// </summary>
        /// <param name="q"> The queue </param>
        /// <param name="i"> The data </param>
        static void Add(queue q, string i)
        {
            if (IsFull(q))
            {
                Console.WriteLine("ERROR -- value not stored");
            }
            else
            {
                if (IsEmpty(q))
                {

                    q.front = q.back = 0;
                    q.data[q.front] = i;

                }
                else
                {
                    if (q.back == 99) // no place left at end 
                        q.back = -1; // cycle around

                    q.back = q.back + 1;
                    q.data[q.back] = i;
                }
            }
        }

        static bool IsFull(queue q)
        {

            return ((q.front == q.back + 1) ||
                ((q.front == 0) && (q.back == 9)));
        }

        static bool IsEmpty(queue q)
        {
            return (q.front == -1);
        }


        static string Front(queue q)
        {
            return (q.data[q.front]);
        }

        static string Back(queue q)
        {
            return (q.data[q.back]);
        }

        static int Size(queue q)
        {
            return (1 + (100 + q.back - q.front) % 100);
        }

        static void PrintQueue(queue q)
        {
            int i, len = Size(q);

            if (IsEmpty(q))
            {
                Console.WriteLine("Queue is empty; nothing to print");
                return;
            }

            for (i = 0; i < len; i++)
                Console.Write(q.data[(q.front + i) % 10] + "\n");
            // modulo operator '%' wraps back into the right array index range

            Console.WriteLine();
            //Console.WriteLine("front = " + q.front + ";   back = " + q.back);
        }

        #endregion
    }
}
